{"version":3,"file":"Scene.js","sourceRoot":"","sources":["../../../src/engine/scene/Scene.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,QAAQ,EAAE,MAAM,2BAA2B,CAAC;AAcrD,MAAM,OAAgB,KAAK;IAYvB,YAAY,KAAkB,EAAE,MAAuB;QAN/C,cAAS,GAAqC,EAAE,CAAC;QAOrD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC,qBAAqB,EAAE,CAAC;QACnD,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IARD,IAAc,QAAQ;QAClB,OAAO,IAAI,CAAC,SAAS,CAAC;IAC1B,CAAC;IAQM,OAAO;QACV,IAAI,CAAC,KAAK,EAAE,CAAC;IACjB,CAAC;IAEM,KAAK;QACR,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACxB,CAAC;IAEM,GAAG,CAAC,WAAyB;QAChC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,WAAW,EAAE,CAAC,CAAC;IAC9C,CAAC;IAEM,MAAM,CAAC,WAAyB;QACnC,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC;QACzE,IAAI,CAAC,aAAa;YACd,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAEtD,aAAa,CAAC,MAAM,GAAG,IAAI,CAAC;IAChC,CAAC;IAEM,MAAM,CAAC,IAAY;QACtB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE;YAC9B,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC;YACtB,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,QAAQ,EAAE;gBACjC,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC;gBAClB,KAAK,CAAC,QAAQ,EAAE,CAAC;aACpB;SACJ;QAED,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;YAC3B,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,OAAO;gBACtB,SAAS;YAEb,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAEnB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC;gBACtD,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;SACvB;IACL,CAAC;IAEM,MAAM;QACT,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;YAC3B,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE;gBACzB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACvC,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC;aACpB;iBAAM,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,MAAM,EAAE;gBAC9B,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACvC,CAAC,CAAC,OAAO,GAAG,KAAK,CAAC;aACrB;YAED,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;SAClB;IACL,CAAC;CACJ","sourcesContent":["import { IScene, ISceneObject } from \"./IScene.js\";\r\nimport { Position } from \"../utils/MovementUtils.js\";\r\n\r\nexport interface ISceneObjectData<TSceneObject> {\r\n    inScene?: boolean;\r\n    remove?: boolean;\r\n    obj: TSceneObject;\r\n}\r\n\r\nexport interface SceneEvent {\r\n    elapsed: number;\r\n    interval: number;\r\n    callback: () => void\r\n}\r\n\r\nexport abstract class Scene<TSceneObject extends ISceneObject> implements IScene<TSceneObject> {\r\n\r\n    protected readonly _board: HTMLElement;\r\n    protected readonly _boundingRect: ClientRect | DOMRect;\r\n    protected readonly _events: Set<SceneEvent>;\r\n\r\n    private __objects: ISceneObjectData<TSceneObject>[] = [];\r\n\r\n    protected get _objects(): ReadonlyArray<ISceneObjectData<TSceneObject>> {\r\n        return this.__objects;\r\n    }\r\n\r\n    constructor(board: HTMLElement, events: Set<SceneEvent>) {\r\n        this._board = board;\r\n        this._boundingRect = board.getBoundingClientRect();\r\n        this._events = events;\r\n    }\r\n\r\n    public prepare(): void {\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._board.innerHTML = \"\";\r\n        this.__objects = [];\r\n    }\r\n\r\n    public add(sceneObject: TSceneObject): void {\r\n        this.__objects.push({ obj: sceneObject });\r\n    }\r\n\r\n    public remove(sceneObject: TSceneObject): void {\r\n        const objForRemoval = this._objects.find(obj => obj.obj === sceneObject);\r\n        if (!objForRemoval)\r\n            throw new Error(\"Object being removed not found\");\r\n\r\n        objForRemoval.remove = true;\r\n    }\r\n\r\n    public update(diff: number): void {\r\n        for (const event of this._events) {\r\n            event.elapsed += diff;\r\n            if (event.elapsed >= event.interval) {\r\n                event.elapsed = 0;\r\n                event.callback();\r\n            }\r\n        }\r\n\r\n        for (const o of this._objects) {\r\n            if (o.remove || !o.inScene)\r\n                continue;\r\n\r\n            o.obj.update(diff);\r\n\r\n            if (!Position.isInside(o.obj.position, this._boundingRect))\r\n                o.remove = true;\r\n        }\r\n    }\r\n\r\n    public render(): void {\r\n        for (const o of this._objects) {\r\n            if (!o.inScene && !o.remove) {\r\n                this._board.appendChild(o.obj.element);\r\n                o.inScene = true;\r\n            } else if (o.inScene && o.remove) {\r\n                this._board.removeChild(o.obj.element);\r\n                o.inScene = false;\r\n            }\r\n\r\n            o.obj.render();\r\n        }\r\n    }\r\n}"]}